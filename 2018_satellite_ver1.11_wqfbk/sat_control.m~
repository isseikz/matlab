function [input] = sat_control(omega, quart, t)
% sat_control.m
% input program
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% design the control law here
% input(1:3) are the input torques for each axis

global Inert torque_max
global casenumber tin
global flag target_1 target_2 target_3

if flag == 1
    q=target_1
elseif flag == 2
    q=target_2;
elseif flag == 3
    q=target_3;
end
    
% q_hat=[ q(4)  q(3) -q(2) -q(1);
%        -q(3)  q(4)  q(1) -q(2);
%         q(2) -q(1)  q(4) -q(3)]*quart;
%     
% Kq=30.0*eye(3);
% Kd=30.0*eye(3);
% 
% input_vec=-Kq*q_hat-Kd*omega;
% 
% input(1) = input_vec(1);
% input(2) = input_vec(2);
% input(3) = input_vec(3);

global u udot

T = 10;
N = 10;
dTau = mod(T,N);

xopt = zeros(7,N);
lambda = zeros(7,N);
input = zeros(1,3);

xopt(1:3,1) = omega;
% xopt(4:7,1) = quart
xopt(4:7,1) = quart - transpose(q);
lambda(:,N) = [0,0,0,q(1),q(2),q(3),q(4)];

u(1,1:N)=ones(1,N)/4/Inert(1);
u(2,1:N)=ones(1,N)/4/Inert(2);
u(3,1:N)=ones(1,N)/4/Inert(3);
u(4,1:N)=ones(1,N)*0.01;

for i=1:N-1
    xopt(:,i+1) = func_new_x(xopt(:,i),u(:,i),dTau);
end
for i = 1:N-1
    lambda(:,N-i) = func_new_lambda(lambda(:,N+1-i), xopt(:,N+1-i), q, dTau);
end

dFdu = zeros(5*N);
F    = zeros(5*N,5*N);
% for i = 1:N
%     d2hdu2 = 4;
%     dFdu(1+5*(i-1):4+5*(i-1)) = d2hdu2(:,:) + 2 *u(:,i);
%     dFdu(5+5*(i-1)) = 2 * ()
%     F(1+5*(i-1):4+5*(i-1)) = func_dhdu(u(1:4,i),lambda(1:4,i),1,0.01);
%     F(5+5*(i-1)) = transpose(u(:,i)) * u(:,i) - 100;
% end

for j=1:N
    for i = 1:5*N
        dFdu(1+5*(i-1):4+5*(i-1),1+5*(i-1):4+5*(i-1)) = 2*(1+mu(j));
        dFdu(5+5*(i-1)) = 2 * mu(j);
    end
   
    F(1+5*(j-1):4+5*(j-1)) = func_dhdu(u(1:4,j),lambda(1:4,j),1,0.01);
    F(5+5*(j-1)) = transpose(u(:,j)) * u(:,j) - 100;
end

% disp(dFdu);
% disp(F)
dudt = gmres(dFdu,-F/0.01,50);
% dudt = dFdu\-F/0.01;
u = func_new_u(u,dudt,dTau,N);

for i = 1:3
    input(i) = u(i,1);
end