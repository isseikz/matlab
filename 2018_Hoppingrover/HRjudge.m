function state = HRjudge(posT)% HRjudge.m%% Judge sate amd terminal conditions%% Revision history% 150520 Created% 150619 Condition of reaching the target is corrected% 150619 TTRTP is expressed as an integer value.% 150619 Kinematical check of state is added.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%global x_ dx_ t_ dth_ smt_global m_HR I_HR r_HR h_HR l_HR alpha g mu_sta mu_dyn e_vx e_vyglobal STATE_A STATE_B STATE_C STATE_Dglobal STATE_E STATE_F STATE_Gglobal VXA_MIN VYA_MINglobal TARGET_WIDTH TARGET_PERIODglobal t_cmdglobal N_pos N_the N_vel N_omg global N_trq N_fA N_fB N_stateglobal N_posAk N_velAk N_posBk N_velBkglobal N_TTRTPglobal successsuccess = 0;pos		= x_(N_pos);the		= x_(N_the);vel		= x_(N_vel);omg		= x_(N_omg);fA		= x_(N_fA);fB		= x_(N_fB);state	= x_(N_state);TTRTP	= x_(N_TTRTP);cos_ta	= cos(the+alpha);sin_ta	= sin(the+alpha);cos_tb	= cos(the-alpha);sin_tb	= sin(the-alpha);posA	= pos + l_HR*[ cos(the+alpha);-sin(the+alpha)];velA	= vel - l_HR*omg*[ sin(the+alpha); cos(the+alpha)];posB	= pos - l_HR*[ cos(the-alpha);-sin(the-alpha)];velB	= vel + l_HR*omg*[ sin(the-alpha); cos(the-alpha)];posC	= pos - l_HR*[ cos(the+alpha);-sin(the+alpha)];posD	= pos + l_HR*[ cos(the-alpha);-sin(the-alpha)];velC	= vel + l_HR*omg*[ sin(the+alpha); cos(the+alpha)];velD	= vel - l_HR*omg*[ sin(the-alpha); cos(the-alpha)];fAx		= fA(1);fAy		= fA(2);vAx		= velA(1);vAy		= velA(2);pAy		= posA(2);fBx		= fB(1);fBy		= fB(2);vBx		= velB(1);vBy		= velB(2);pBy		= posB(2);vCy		= velC(2);pCy		= posC(2);vDy		= velD(2);pDy		= posD(2);%%% top side is fragile (if it is collided with the surface, it will brake off.)switch state,	case {STATE_B,STATE_C},		if ( abs(posA(1)-posT(1))-TARGET_WIDTH/2<=eps ),			TTRTP = TTRTP+dth_;		end	case {STATE_D,STATE_E},		if ( abs(posB(1)-posT(1))-TARGET_WIDTH/2<=eps ),			TTRTP = TTRTP+dth_;		end	case {STATE_F,STATE_G},		if ( (abs(posA(1)-posT(1))-TARGET_WIDTH/2<=eps) | ...			 (abs(posB(1)-posT(1))-TARGET_WIDTH/2<=eps) ),			TTRTP = TTRTP+dth_;		end	otherwise,		TTRTP = 0;endif ( TTRTP>=TARGET_PERIOD ),	disp(sprintf('Hurrah! The rover has reached the target point at %5.0f s (TTRTP)', round(t_)));    success = 1;	smt_ = t_;	x_(N_TTRTP)	= TTRTP;	return;endx_(N_TTRTP)	= TTRTP;%%% top side is fragile (if it is collided with the surface, it will brake off.)if ( (pCy < -eps) & (vCy < 0) )	disp(sprintf('Ouch! The top side hits the surface and gets broken.\nSimulation is terminated.'));	smt_ = t_;		% set simulation time as the current time	return;			% so that the main program breaks.endif ( (pDy < -eps) & (vDy < 0) )	disp(sprintf('Ouch! The top side hits the surface and gets broken.\nSimulation is terminated.'));	smt_ = t_;		% set simulation time as the current time	return;			% so that the main program breaks.endc_at_A	= 0;		% 1:contact at point A, 0:no contact at pointAc_at_B	= 0;		% 1:contact at point B, 0:no contact at pointBd_vel	= [0;0];	% change in velocity due to contactd_omg	= 0;		% change in omega due to contact%%% contact dynamics (impulse approximation)if ( pAy < -eps ),	if ( vAy < -eps ),		vAy = - e_vy*vAy;		vAx =   e_vx*vAx;		c_at_A = 1;		%%% deadband in velocity		if ( abs(vAy)<VYA_MIN ),			vAy = 0;		end		if ( abs(vAx)<VXA_MIN ),			vAx = 0;		end	endendif ( pBy < -eps),	if ( vBy < -eps ),		vBy = - e_vy*vBy;		vBx =   e_vx*vBx;		c_at_B = 1;		%%% deadband in velocity		if ( abs(vBy)<VYA_MIN ),			vBy = 0;		end		if ( abs(vBx)<VXA_MIN ),			vBx = 0;		end	endend%--- contact at point Aif ( (c_at_A==1) & (c_at_B==0) ),	d_vAy	= vAy - velA(2);	d_vAx	= vAx - velA(1);	mat_A	= [1/m_HR + l_HR^2/I_HR*sin_ta^2, l_HR^2/I_HR*sin_ta*cos_ta;...	           l_HR^2/I_HR*sin_ta*cos_ta,     1/m_HR + l_HR^2/I_HR*cos_ta^2];	int_fA	= inv(mat_A)*[d_vAx;d_vAy];	d_vel	= 1/m_HR*int_fA;	d_omg	= l_HR*[-sin_ta, -cos_ta]*int_fA/I_HR;		d_vBx	= d_vel(1)+l_HR*d_omg*sin_tb;	d_vBy	= d_vel(2)+l_HR*d_omg*cos_tb;	vBx		= velB(1) + d_vBx;	vBy		= velB(2) + d_vBy;end%--- contact at point Bif ( (c_at_A==0) & (c_at_B==1) ),	d_vBy	= vBy - velB(2);	d_vBx	= vBx - velB(1);	mat_B	= [1/m_HR + l_HR^2/I_HR*sin_tb^2, l_HR^2/I_HR*sin_tb*cos_tb;...	           l_HR^2/I_HR*sin_tb*cos_tb,     1/m_HR + l_HR^2/I_HR*cos_tb^2];	int_fB	= inv(mat_B)*[d_vBx;d_vBy];	d_vel	= 1/m_HR*int_fB;	d_omg	= l_HR*[ sin_tb, cos_tb]*int_fB/I_HR;		d_vAx	= d_vel(1)-l_HR*d_omg*sin_ta;	d_vAy	= d_vel(2)-l_HR*d_omg*cos_ta;	vAx		= velA(1) + d_vAx;	vAy		= velA(2) + d_vAy;end%--- contact at points A and Bif ( (c_at_A==1) & (c_at_B==1) ),	d_vAy	= vAy - velA(2);	d_vAx	= vAx - velA(1);	d_vBy	= vBy - velB(2);	d_vBx	= vBx - velB(1);	mat_AB	= [1/m_HR + l_HR^2/I_HR*sin_ta^2,...			   1/m_HR - l_HR^2/I_HR*sin_ta*sin_tb,...			            l_HR^2/I_HR*sin_ta*cos_ta,...			          - l_HR^2/I_HR*sin_ta*cos_tb;...			          			   1/m_HR - l_HR^2/I_HR*sin_tb*sin_ta,...			   1/m_HR + l_HR^2/I_HR*sin_tb^2,...			          - l_HR^2/I_HR*sin_tb*cos_ta,...			            l_HR^2/I_HR*sin_tb*cos_tb;...			            			            l_HR^2/I_HR*cos_ta*sin_ta,...			          - l_HR^2/I_HR*cos_ta*sin_tb,...			   1/m_HR + l_HR^2/I_HR*cos_ta^2,...			   1/m_HR - l_HR^2/I_HR*cos_ta*cos_tb;...			   			          - l_HR^2/I_HR*cos_tb*sin_ta,...			            l_HR^2/I_HR*cos_tb*sin_tb,...			   1/m_HR - l_HR^2/I_HR*cos_tb*cos_ta,...			   1/m_HR + l_HR^2/I_HR*cos_tb^2];	int_fAB	= pinv(mat_AB)*[d_vAx;d_vBx;d_vAy;d_vBy];	d_vel	= 1/m_HR*[sum(int_fAB(1:2));sum(int_fAB(3:4))];	d_omg	= l_HR*[-sin_ta, sin_tb, -cos_ta, cos_tb]*int_fAB/I_HR;endomg	= x_(N_omg) + d_omg;vel	= x_(N_vel) + d_vel;velA(2) = vAy;velB(2) = vBy;velA(1) = vAx;velB(1) = vBx;%%%%%% mode transition%%%switch state,	%--- Contact Point A	case STATE_B,		if ( fAy <= 0 ),			state = STATE_A;	% Contact force is zero.		else			if (abs(fAx) > mu_sta*fAy),				state = STATE_C;	% Sliding begins.			end			if ((pBy <= -eps) & (vBy == 0)),				state = STATE_F;	% Point B is fixed.			end		end	case STATE_C,		if ( fAy <= 0 ),			state = STATE_A;	% Contact force is zero.		else			if ( abs(vAx) < eps ),				state = STATE_B;	% Sliding stops.			end			if ((pBy <= -eps) & (vBy == 0)),				state = STATE_G;	% Point B is lowered.			end		end	%--- Contact Point B	case STATE_D,		if ( fBy <= 0 ),			state = STATE_A;	% Contact force is zero.		else			if (abs(fBx) > mu_sta*fBy),				state = STATE_E;	% Sliding begins.			end			if ((pAy <= -eps) & (vAy == 0)),				state = STATE_F;	% Sliding stops.			end		end	case STATE_E, 		if ( fBy <= 0 ),			state = STATE_A;	% Contact force is zero.		else			if ( abs(vBx) < eps ),				state = STATE_D;	% Sliding stops.			end			if ((pAy <= -eps) & (vAy == 0)),				state = STATE_G;	% Point A is lowered.			end		end	%--- Contact Points A and B	case STATE_F,		if ( (fAy <= 0) & (fBy <= 0) ),			state = STATE_A;	% Contact force is zero.		else			if ( (fAy > 0) & (fBy <= 0) ),				state = STATE_B;	% Point B is lifted.			end			if ( (fBy > 0) & (fAy <= 0) ),				state = STATE_D;	% Point A is lifted.			end			if ( (fAy > 0) & (fBy > 0) )				if ((abs(fAx) > mu_sta*fAy) & (abs(fBx) > mu_sta*fBy)),					state = STATE_G;	% Sliding begins.				end			end		end	case STATE_G,		if ( (fAy <= 0) & (fBy <= 0) ),			state = STATE_A;	% Contact force is zero.		else			if ( (fAy > 0) & (fBy <= 0) ),				state = STATE_C;	% Point B is lifted.			end			if ( (fBy > 0) & (fAy <= 0) ),				state = STATE_E;	% Point A is lifted.			end			if ( (fAy > 0) & (fBy > 0) ),				if ( (abs(vAx) < eps) & (abs(vBx) < eps) ),					state = STATE_F;	% Sliding stops.				end			end		end	%--- Hop	case STATE_A,		if ( (pAy<=-eps)&(pBy>eps) ),	% Re-lands on A.			if ( vAy==0 )				if ( vAx==0 ),					state = STATE_B;	% Pivots.				else					state = STATE_C;	% Slides.				end			end		end		if ( (pBy<=-eps)&(pAy>eps) ),	% Re-lands on B.			if ( vBy==0 )				if ( vBx==0 ),					state = STATE_D;	% Povits.				else					state = STATE_E;	% Slides.				end			end		end		if ( (pAy<=-eps)&(pBy<=-eps) ),	% Re-lands on A&B.			if ( (vAy==0)&(vBy==0) )				if ( (vAx==0) & (vBx==0) ),					state = STATE_F;	% Stops.				else					state = STATE_G;	% Slides.				end			end		end	otherwise,		disp(sprintf('state is undefined %s',char(64+state)));		pauseend%%%%%%  check state kinematically%%%state = set_state(pos,vel,the,omg,state);x_(N_state)	= state;x_(N_posAk)	= posA;x_(N_velAk)	= velA;x_(N_posBk)	= posB;x_(N_velBk)	= velB;x_(N_vel)	= vel;x_(N_omg)	= omg;x_(N_TTRTP)	= TTRTP;